"""
tc3625.py - high level python API for the TC-36-25 thermoelectric cooler
temperature controllers. 

The high level API provides a wrapper around the low level serial
interface provided by the TC3625_Serial class. The high level API
provides human pneumonics for the various controller settings, and
enables set-point values, limits, gains etc to be set directly in deg
F or deg C. 

Classes:
  TC3625

Functions:
  fp2dec
  dec2fp
  amp2cnt
  cnt2amp
  val2str

Usage:


Author: Will Dickson
"""
from tc3625_serial import TC3625_Serial

# Default port settings
DFLT_PORT='/dev/ttyS0'
DFLT_TIMEOUT=2.0
DFLT_BAUDRATE=9600
DFLT_MAX_ATTEMPT=10

# Min and max power integer (fp) values
POWER_MIN_INT=-511
POWER_MAX_INT=511

# Alarm constants and also bit positions in low level 
# return values.
ALARM_HIGH=0
ALARM_LOW=1
ALARM_COMPUTER_CONTROLLED=2
ALARM_OVER_CURRENT=3
ALARM_OPEN_INPUT1=4
ALARM_OPEN_INPUT2=5
ALARM_DRIVER_LOW_VOLTAGE=6
ALARMS=(
    ALARM_HIGH,
    ALARM_LOW,
    ALARM_COMPUTER_CONTROLLED,
    ALARM_OVER_CURRENT,
    ALARM_OPEN_INPUT1,
    ALARM_OPEN_INPUT2,
    ALARM_DRIVER_LOW_VOLTAGE,
    )
ALARM_STR={
    ALARM_HIGH:'high', 
    ALARM_LOW:'low',
    ALARM_COMPUTER_CONTROLLED:'computer controlled',
    ALARM_OVER_CURRENT:'over current',
    ALARM_OPEN_INPUT1:'open input1',
    ALARM_OPEN_INPUT2:'open input2',
    ALARM_DRIVER_LOW_VOLTAGE: 'driver low voltage',
    }

# Alarm type settings
ALARM_TYPE_NONE=0
ALARM_TYPE_TRACKING=1
ALARM_TYPE_FIXED=2
ALARM_TYPE_COMPUTER=3
ALARM_TYPES=(
    ALARM_TYPE_NONE,
    ALARM_TYPE_TRACKING,
    ALARM_TYPE_FIXED,
    ALARM_TYPE_COMPUTER,
    )
ALARM_TYPE_STR={
    ALARM_TYPE_NONE:'none',
    ALARM_TYPE_TRACKING:'tracking',
    ALARM_TYPE_FIXED:'fixed',
    ALARM_TYPE_COMPUTER:'computer',
    }

# Set-point type settings
SETPT_TYPE_COMPUTER=0
SETPT_TYPE_POTENTIOMETER=1
SETPT_TYPE_VOLTAGE=2
SETPT_TYPE_CURRENT=3
SETPT_TYPE_DIFFERENTIAL=4
SETPT_TYPE_MP2986=5
SETPT_TYPES=(
    SETPT_TYPE_COMPUTER,
    SETPT_TYPE_POTENTIOMETER,
    SETPT_TYPE_VOLTAGE,
    SETPT_TYPE_CURRENT,
    SETPT_TYPE_DIFFERENTIAL,
    SETPT_TYPE_MP2986,
    )
SETPT_STR={
    SETPT_TYPE_COMPUTER:'computer',
    SETPT_TYPE_POTENTIOMETER:'potentiometer',
    SETPT_TYPE_VOLTAGE:'0-5V input',
    SETPT_TYPE_CURRENT:'20mA input',
    SETPT_TYPE_DIFFERENTIAL:'differential set',
    SETPT_TYPE_MP2986:'MP-2986 display',
    }

# Sensor type settings
SENSOR_TYPE_TS141_5K=0
SENSOR_TYPE_TS67_TS136_15K=1
SENSOR_TYPE_TS91_10K=2
SENSOR_TYPE_TS165_230K=3
SENSOR_TYPE_TS104_50K=4
SENSOR_TYPE_YSI_H_TP53_10K=5
SENSOR_TYPES=(
    SENSOR_TYPE_TS141_5K,
    SENSOR_TYPE_TS67_TS136_15K,
    SENSOR_TYPE_TS91_10K,
    SENSOR_TYPE_TS165_230K,
    SENSOR_TYPE_TS104_50K,
    SENSOR_TYPE_YSI_H_TP53_10K,
)
SENSOR_TYPE_STR={
    SENSOR_TYPE_TS141_5K:'TS141 5K',
    SENSOR_TYPE_TS67_TS136_15K:'TS67 or TS136 15K',
    SENSOR_TYPE_TS91_10K:'TS91 10K',
    SENSOR_TYPE_TS165_230K:'TS165 230K',
    SENSOR_TYPE_TS104_50K:'TS104 50K',
    SENSOR_TYPE_YSI_H_TP53_10K:'YSI H TP53 10K',
    }

# Control types
CONTROL_TYPE_DEADBAND=0
CONTROL_TYPE_PID=1
CONTROL_TYPE_COMPUTER=2
CONTROL_TYPES=(
    CONTROL_TYPE_DEADBAND,
    CONTROL_TYPE_PID,
    CONTROL_TYPE_COMPUTER,
    )
CONTROL_TYPE_STR={
    CONTROL_TYPE_DEADBAND:'deadband',
    CONTROL_TYPE_PID:'PID',
    CONTROL_TYPE_COMPUTER:'computer',
    }   
# Ouput polarities
POLARITY_HEAT_WP1POS_WP2NEG=0
POLARITY_HEAT_WP2POS_WP1NEG=1
POLARITY_TYPES=(
    POLARITY_HEAT_WP1POS_WP2NEG,
    POLARITY_HEAT_WP2POS_WP1NEG,
    )
POLARITY_STR={
    POLARITY_HEAT_WP1POS_WP2NEG:'heat WP1+ and WP2-',
    POLARITY_HEAT_WP2POS_WP1NEG:'heat WP2+ and WP1-',
    }

# Power states
POWER_OFF=0
POWER_ON=1
POWER_TYPES=(
    POWER_ON, 
    POWER_OFF,
    )
POWER_STR={
    POWER_ON:'on',
    POWER_OFF:'off',
    }

# Shutdown if alarm states
SHUTDOWN_IF_ALARM_OFF=0
SHUTDOWN_IF_ALARM_ON=1
SHUTDOWN_IF_ALARM_TYPES=(
    SHUTDOWN_IF_ALARM_OFF,
    SHUTDOWN_IF_ALARM_ON,
    )
SHUTDOWN_IF_ALARM_STR={
    SHUTDOWN_IF_ALARM_OFF:'off',
    SHUTDOWN_IF_ALARM_ON:'on',
    }
# Integral gain min and max 
INTEGRAL_GAIN_MIN=0
INTEGRAL_GAIN_MAX=10
INTEGRAL_GAIN_RANGE=(
    INTEGRAL_GAIN_MIN,
    INTEGRAL_GAIN_MAX,
    )

# Derivative gain 
DERIVATIVE_GAIN_MIN=0
DERIVATIVE_GAIN_MAX=10
DERIVATIVE_GAIN_RANGE=(
    DERIVATIVE_GAIN_MIN,
    DERIVATIVE_GAIN_MAX,
    )
    
# Max and min heat multipliers
HEAT_MULTIPLIER_MIN=0.0
HEAT_MULTIPLIER_MAX=2.0

# Max and min cool multipliers
COOL_MULTIPLIER_MIN=0.0
COOL_MULTIPLIER_MAX=2.0

# Amps per count
AMPS_PER_COUNT=2.5

# Min and max over current level
OVER_CURRENT_MIN=0
OVER_CURRENT_MAX=40
OVER_CURRENT_RANGE=(
    OVER_CURRENT_MIN,
    OVER_CURRENT_MAX,
    )
    
# Alarm latch settings
ALARM_LATCH_OFF=0
ALARM_LATCH_ON=1
ALARM_LATCH_TYPES = (
    ALARM_LATCH_OFF,
    ALARM_LATCH_ON,
    )
ALARM_LATCH_STR={
    ALARM_LATCH_OFF:'off',
    ALARM_LATCH_ON:'on',
    }
    
# Alarm sensor type
ALARM_SENSOR_INPUT1=0
ALARM_SENSOR_INPUT2=1
ALARM_SENSOR_TYPES=(
    ALARM_SENSOR_INPUT1,
    ALARM_SENSOR_INPUT2,
    )
ALARM_SENSOR_STR={
    ALARM_SENSOR_INPUT1:'input1',
    ALARM_SENSOR_INPUT2:'input2',
    }

# Temperature units
TEMP_F=0    
TEMP_C=1
TEMP_TYPES=(
    TEMP_F,
    TEMP_C,
    )
TEMP_STR={
    TEMP_F:'F',
    TEMP_C:'C',
    }

# EEPROM write values
EEPROM_WRITE_OFF=0
EEPROM_WRITE_ON=1
EEPROM_WRITE_TYPES=(
    EEPROM_WRITE_OFF,
    EEPROM_WRITE_ON,
    )
EEPROM_WRITE_STR={
    EEPROM_WRITE_OFF:'off',
    EEPROM_WRITE_ON:'on',
    }

# Over current settings
OVER_CURRENT_RESTART_MAX_ATTEMPT=0
OVER_CURRENT_RESTART_CONTINUOUS=1    
OVER_CURRENT_RESTART_TYPES=(
    OVER_CURRENT_RESTART_MAX_ATTEMPT,
    OVER_CURRENT_RESTART_CONTINUOUS,
    )
OVER_CURRENT_RESTART_STR={
    OVER_CURRENT_RESTART_MAX_ATTEMPT:'max attempt',
    OVER_CURRENT_RESTART_CONTINUOUS:'continuous',
    }
    
# Min and max over current restart attempt values
OVER_CURRENT_RESTART_MIN=0
OVER_CURRENT_RESTART_MAX=30000
OVER_CURRENT_RESTART_RANGE=(
    OVER_CURRENT_RESTART_MIN,
    OVER_CURRENT_RESTART_MAX,
    )

# JP3 display settings
JP3_DISPLAY_OFF=0
JP3_DISPLAY_ON=1
JP3_DISPLAY_TYPES=(
    JP3_DISPLAY_OFF,
    JP3_DISPLAY_ON,
    )
JP3_DISPLAY_STR={
    JP3_DISPLAY_OFF:'off',
    JP3_DISPLAY_ON:'on',
    }
    
class TC3625:
    """
    High level python API for the TC-36-25 thermoelectric cooler
    temperature contollers.
    """
    def __init__(self, 
                 port=DFLT_PORT, 
                 timeout=DFLT_TIMEOUT,
                 baudrate=DFLT_BAUDRATE,
                 max_attempt=DFLT_MAX_ATTEMPT,
                 open=True,
                 eeprom='off',
                 ):
        self.port=port
        self.timeout=timeout
        self.baudrate=baudrate
        self.max_attempt=max_attempt    
        if open==True:
            flag = self.open()
            if flag==False:
                raise IOError, 'unable to open device'
        if eeprom=='off':
            self.set_eeprom_write(EEPROM_WRITE_OFF)

        self.get_set_dict = {
            'input1':{
                'get':self.get_input1,
                'set':None,
                },
            'input2': {
                'get':self.get_input2,
                'set':None,
                },
            'control value':{
                'get':self.get_control_value,
                'set':None,
                },
            'power output':{
                'get':self.get_power_output,
                'set':None,
                },
            'alarm status':{
                'get':self.get_alarm_status,
                'set':None,
                },
            'output current':{
                'get':self.get_output_current,
                'set':None,
                },
            'alarm type':{
                'get':self.get_alarm_type,
                'set':self.set_alarm_type,
                },
            'setpt type':{
                'get':self.get_setpt_type,
                'set':self.set_setpt_type,
                },
            'sensor type':{
                'get':self.get_sensor_type,
                'set':self.set_sensor_type,
                },
            'control type':{
                'get':self.get_control_type,
                'set':self.set_control_type,
                },
            'output polarity':{
                'get':self.get_output_polarity,
                'set':self.set_output_polarity,
                },
            'power state': {
                'get':self.get_power_state,
                'set':self.set_power_state,
                },
            'shutdown if alarm': {
                'get':self.get_shutdown_if_alarm,
                'set':self.set_shutdown_if_alarm,
                },
            'fixed control setting':{
                'get':self.get_fixed_control_setting,
                'set':self.set_fixed_control_setting,
                },
            'setpt':{
                'get':self.get_setpt,
                'set':self.set_setpt,
                },
            'proportional bandwidth':{
                'get':self.get_proportional_bandwidth,
                'set':self.set_proportional_bandwidth,
                },
            'integral gain':{
                'get':self.get_integral_gain,
                'set':self.set_integral_gain,
                },
            'derivative gain':{
                'get':self.get_derivative_gain,
                'set':self.set_derivative_gain,
                },
            'low external set range':{
                'get':self.get_low_external_set_range,
                'set':self.set_low_external_set_range,
                },
            'high external set range':{
                'get':self.get_high_external_set_range,
                'set':self.set_high_external_set_range,
                },
            'alarm deadband':{
                'get':self.get_alarm_deadband,
                'set':self.set_alarm_deadband,
                },
            'high alarm':{
                'get':self.get_high_alarm,
                'set':self.set_high_alarm,
                },
            'low alarm':{
                'get':self.get_low_alarm,
                'set':self.set_low_alarm,
                },
            'control deadband':{
                'get':self.get_control_deadband,
                'set':self.set_control_deadband,
                },
            'input1 offset':{
                'get':self.get_input1_offset,
                'set':self.set_input1_offset,
                },
            'input2 offset':{
                'get':self.get_input2_offset,
                'set':self.set_input2_offset,
                },
            'heat multiplier':{
                'get':self.get_heat_multiplier,
                'set':self.set_heat_multiplier,
                },
            'cool multiplier':{
                'get':self.get_cool_multiplier,
                'set':self.set_cool_multiplier,
                },
            'over current compare':{
                'get':self.get_over_current_compare,
                'set':self.set_over_current_compare,
                },
            'alarm latch':{
                'get':self.get_alarm_latch,
                'set':self.set_alarm_latch,
                },
            'alarm sensor':{
                'get':self.get_alarm_sensor,
                'set':self.set_alarm_sensor,
                },
            'working units':{
                'get':self.get_working_units,
                'set':self.set_working_units,
                },
            'eeprom write':{
                'get':self.get_eeprom_write,
                'set':self.set_eeprom_write,
                },
            'over current restart type':{
                'get':self.get_over_current_restart_type,
                'set':self.set_over_current_restart_type,
                },
            'over current restart num':{
                'get':self.get_over_current_restart_num,
                'set':self.set_over_current_restart_num,
                },
            'JP3 display':{
                'get':self.get_JP3_display,
                'set':self.set_JP3_display,
                },
            }            

    def set_by_dict(self,prop_new):
        """
        Set deivce properties using dictionary
        """
        keys = self.get_set_dict.keys()
        for k in prop_new.keys():
            if not k in keys:
                raise ValueError, 'unknown property %s'%(k,)
            self.set(k,prop_new[k])

    def set(self,prop_str,val):
        """
        Set device property by name value pair
        """
        if not prop_str in self.get_set_dict.keys():
            raise ValueError, 'unknown property %s'%(str(prop_str),)
        if self.get_set_dict[prop_str]['set']==None:
            raise ValueError, 'unsettable property %s'%(str(prop_str,))
        self.get_set_dict[prop_str]['set'](val)
            

    def get_all_prop(self):
        """
        Get all device properties
        """
        prop={}
        for k in self.get_set_dict:
            if self.get_set_dict[k]!=None:
                prop[k]=self.get_set_dict[k]['get']()
        return prop

    def print_all_prop(self):
        """
        Print all device properties
        """
        prop = self.get_all_prop()
        prop_keys = prop.keys()
        prop_keys.sort()
        for p in prop_keys:
            self.print_prop(p,prop[p])

    def print_prop(self,prop_str,val):
        """
        Print device property 
        """
        val_str = val2str(prop_str,val)
        print '%s: %s'%(prop_str, val_str)
        
        
    def open(self):
        """ 
        Open serial connection to device. Note, by defualt the serial
        connection to the device is automatically open on
        initialization.
        """
        self.dev = TC3625_Serial(port=self.port)
        flag = self.dev.open()
        return flag
        
    def close(self):
        """ Close serial conection to device """
        self.dev.close()

    def _get_value(self,cmd): 
        """ 
        Generic get commmand - tries max_attempt times to read value
        from device using low level serial protocol.
        """
        cnt=0
        while cnt < self.max_attempt:
            try:
                val = self.dev.read(cmd)
                break
            except IOError:
                print '** warning IOError on read'
                pass
            cnt+=1
        if cnt==self.max_attempt:
            raise IOError, 'max attempts reached for read'
        return val
                
    def _set_value(self,cmd,val):
        """
        Generic set command - tries max_attempt times to set device
        value using low level serial protocol.
        """
        cnt=0
        while cnt < self.max_attempt:
            try:
                val = self.dev.write(cmd,val)
                break
            except IOError:
                print '** warning IOError on write'
                pass
            cnt+=1
        if cnt==self.max_attempt:
            raise IOError, 'max attempts reached for write'
        return val

    def get_input1(self):
        """
        Reads the temperature of the primary thermister temperature
        sensor. Returned as either deg F or deg C value depending on
        working units.
        """
        val_fp=self._get_value('input1')
        return fp2dec(val_fp)
        
    def get_input2(self):
        """
        Reads the temperature of the secondary thermister temperature
        sensor. Returned as either deg F or deg C value depending on
        working units.
        """
        val_fp=self._get_value('input2')
        return fp2dec(val_fp)

    def get_control_value(self):
        """
        This command returns the set value determined by input2 or as
        a temprature value set by communications. 

        ?? I'm not sure I really understand this quantity 
        """
        val_fp = self._get_value('desired control value')
        # Need to do some conversions here, I think it is fp2dec?
        return fp2dec(val_fp)

    def get_power_output(self):
        """
        Reads power output as percentage. 
        """
        val=self._get_value('power output')
        return 100.0*val/float(POWER_MAX_INT)

    def get_alarm_status(self):
        """
        Returns a tuple consisting of an alarm flag and a list of of
        all active alarms. The alarm flag will be False and the list
        empty if there are no active alarms. 

        Usage:
        flag, alarm_list = ctrl.get_alarm_status()
        """
        val=self._get_value('alarm status')
        alarm_list=[]
        if val==0:
            return False, alarm_list
        else:
            for a in ALARMS:
                if (1<<a)&val != 0:
                    alarm_list.append(a)
            return True, alarm_list

    def get_output_current(self):
        """
        Returns output current in Amps.
        """
        val=self._get_value('output current counts')
        val_amp = cnt2amp(val)
        return val_amp
    
    def get_alarm_type(self):
        """
        Returns current alarm type setting. Allowed values are 
        ALARM_TYPE_NONE, ALARM_TYPE_TRACKING, ALARM_TYPE_FIXED, and
        ALARM_TYPE_COMPUTER.
        """
        val=self._get_value('alarm type')
        if not val in ALARM_TYPES:
            raise IOError, 'unknown alarm type from get'
        return val

    def set_alarm_type(self, val):
        """
        Set the alarm type. Allowed values are ALARM_TYPE_NONE,
        ALARM_TYPE_TRACKING, ALARM_TYPE_FIXED, and ALARM_TYPE_COMPUTER.
        See the TC-36-25 operation manual for details. 
        """
        if not val in ALARM_TYPES:
            raise ValueError, 'unkown alarm type for set'
        val=self._set_value('alarm type',val)
        return val
    
    def get_setpt_type(self):
        """
        Returns the current set-point type. Allowed values are 
        SETPT_TYPE_COMPUTER - computer communicated value 
        SETPT_TYPE_POTENTIOMETER - potentiometer input
        SETPT_TYPE_VOLTAGE - 0 to 5V input
        SETPT_TYPE_CURRENT - 0 to 20mA input 
        SETPT_TYPE_DIFFERENTIAL - differential set (desired control value = 
         temp2+computer set)
        SETPT_TYPE_MP2986 - value from optional MP-2986 display
        """
        val=self._get_value('set type define')
        if not val in SETPT_TYPES:
            raise IOError, 'unknown set-point type from get'
        return val

    def set_setpt_type(self,val):
        """
        Set the set-point type. Allowed values are
        SETPT_TYPE_COMPUTER - computer communicated value 
        SETPT_TYPE_POTENTIOMETER - potentiometer input
        SETPT_TYPE_VOLTAGE - 0 to 5V input
        SETPT_TYPE_CURRENT - 0 to 20mA input 
        SETPT_TYPE_DIFFERENTIAL - differential set (desired control value = 
         temp2+computer set)
        SETPT_TYPE_MP2986 - value from optional MP-2986 display
        """
        if not val in SETPT_TYPES:
            raise ValueError, 'unknown set-point type for set'
        val=self._set_value('set type define',val)
        return val

    def get_sensor_type(self):
        """
        Returns current sensor type setting. Allowed values are
        SENSOR_TYPE_TS141_5K
        SENSOR_TYPE_TS67_TS136_15K
        SENSOR_TYPE_TS91_10K
        SENSOR_TYPE_TS165_230K
        SENSOR_TYPE_TS104_50K
        SENSOR_TYPE_YSI_H_TP53_10K
        """
        val=self._get_value('sensor type')
        if not val in SENSOR_TYPES:
            raise IOError, 'unknown sensor type from get'
        return val

    def set_sensor_type(self, val):
        """
        Sets the sensor type. Allowed values
        SENSOR_TYPE_TS141_5K
        SENSOR_TYPE_TS67_TS136_15K
        SENSOR_TYPE_TS91_10K
        SENSOR_TYPE_TS165_230K
        SENSOR_TYPE_TS104_50K
        SENSOR_TYPE_YSI_H_TP53_10K
        """
        if not val in SENSOR_TYPES:
            raise ValueError, 'unknown sensor type for set'
        val=self._set_value('sensor type',val)
        return val

    def get_control_type(self):
        """
        Returns the current control type setting. Allowed values are
        CONTROL_TYPE_DEADBAND
        CONTROL_TYPE_PID
        CONTROL_TYPE_COMPUTER
        """
        val=self._get_value('control type')
        if not val in CONTROL_TYPES:
            raise IOError, 'unknown control type from get'
        return val

    def set_control_type(self,val):
        """
        Set the control type. Allowed calues are 
        CONTROL_TYPE_DEADBAND
        CONTROL_TYPE_PID
        CONTROL_TYPE_COMPUTER
        """
        if not val in CONTROL_TYPES:
            raise ValueError, 'unknown control type for set'
        val=self._set_value('control type',val)
        return val

    def get_output_polarity(self):
        """
        Returns the current control output polarity setting. Allowed values are 
        POLARITY_HEAT_WP1POS_WP2NEG
        POLARITY_HEAT_WP2POS_WP1NEG
        """
        val=self._get_value('control output polarity')
        if not val in POLARITY_TYPES:
            raise IOError, 'unknown polarity type from get'
        return val

    def set_output_polarity(self, val):
        """
        Set the control output polarity setting. Allowed values are 
        POLARITY_HEAT_WP1POS_WP2NEG
        POLARITY_HEAT_WP2POS_WP1NEG
        """
        if not val in POLARITY_TYPES:
            raise ValueError, 'unknown polarity type for set'
        val=self._set_value('control output polarity', val)
        return val
        
    def get_power_state(self):
        """
        Returns the current state of the system power output.  Allowed
        values POWER_ON or POWER_OFF
        """
        val=self._get_value('power on/off')
        if not val in POWER_TYPES:
            raise IOError, 'unknown power type from get'
        return val

    def set_power_state(self,val):
        """
        Set the power state of the system. Allowed values POWER_ON or
        POWER_OFF
        """
        if not val in POWER_TYPES:
            raise ValueError, 'unknown power type for set'
        val=self._set_value('power on/off',val)
        return val
        
    def power_on(self):
        """
        Turn on the system output power. 
        """
        self.set_power_state(POWER_ON)
        
    def power_off(self):
        """
        Turn off the system output power.
        """
        self.set_power_state(POWER_OFF)
    
    def get_shutdown_if_alarm(self):
        """
        Return the current value of the 'output shutdown if alarm' setting 
        of the controller. Allowed values SHUTDOWN_IF_ALARM_OFF and 
        SHUTDOWN_IF_ALARM_ON,
        """
        val=self._get_value('output shutdown if alarm')
        if not val in SHUTDOWN_IF_ALARM_TYPES:
            raise IOError, 'unknown shutdown if alarm type from get'
        return val

    def set_shutdown_if_alarm(self,val):
        """
        Set the 'output shutdown if alarm' setting of the controller. 
        Allowed values SHUTDOWN_IF_ALARM_OFF and  SHUTDOWN_IF_ALARM_ON,
        """
        if not val in SHUTDOWN_IF_ALARM_TYPES:
            raise ValueError, 'unknown shutdown if alarm type for set'
        val=self._set_value('output shutdown if alarm',val)
        return val

    def get_fixed_control_setting(self):
        """
        Return the fixed desired control setting. 
        
        When control type is CONTROL_TYPE_DEADBAND or CONTROL_TYPE_PID
        this corresponds to the set-point temperature in either deg F
        or deg C depedning on the working units.
        
        When control type is CONTROL_TYPE_COMPUTER this corresponds
        with the output power setting and should be in the range
        [-5.11, 5.11]
        """
        val_fp=self._get_value('fixed desired control setting')
        return fp2dec(val_fp)

    def set_fixed_control_setting(self,val):
        """
        Sets the fixed desired control setting. 
        
        When control type is CONTROL_TYPE_DEADBAND or CONTROL_TYPE_PID
        this corresponds to the set-point temperature in either deg F
        or deg C depedning on the working units.
        
        When control type is CONTROL_TYPE_COMPUTER this corresponds
        with the output power setting and should be in the range
        [-5.11, 5.11]
        """
        val_fp=dec2fp(val)
        val_fp=self._set_value('fixed desired control setting',val_fp)
        return fp2dec(val_fp)

    def get_setpt(self):
        """
        Return the current set-point. (Note this command is just an
        alias for get_fixed_control_setting.)
        
        When control type is CONTROL_TYPE_DEADBAND or CONTROL_TYPE_PID
        this corresponds to the set-point temperature in either deg F
        or deg C depedning on the working units.
        
        When control type is CONTROL_TYPE_COMPUTER this corresponds
        with the output power setting and should be in the range
        [-5.11, 5.11]
        """
        return self.get_fixed_control_setting()
        
    def set_setpt(self,val):
        """
        Sets the controller's set-point value. (Note this command is just an
        alias for set_fixed_control_setting.)

        When control type is CONTROL_TYPE_DEADBAND or CONTROL_TYPE_PID
        this corresponds to the set-point temperature in either deg F
        or deg C depedning on the working units.
        
        When control type is CONTROL_TYPE_COMPUTER this corresponds
        with the output power setting and should be in the range
        [-5.11, 5.11]
        """
        return self.set_fixed_control_setting(val)
        
    def get_proportional_bandwidth(self):
        """
        Return the controller's proportional bandwidth setting. This is
        the temperature range, in deg F or C, over which the output
        power is proportioned from -100% to 100%. The bandwidth is
        cenetered about the set-point value. The controller ouput
        power is 100% at the end of the bandwidth range above the
        set-point, it decreases to 0% as it reaches the set-point, and
        is -100% at the end of the bandwidth range below the
        set-point.

        If the bandwidth is too narrow the temperature will oscillate
        around the set-point. If it is too wide the controller will be
        slow to respond.
        """
        val=self._get_value('proportional bandwidth')
        return fp2dec(val)

    def set_proportional_bandwidth(self, val):
        """
        Set the controller's proportional bandwidth. This is the
        temperature range, in deg F or C, over which the output power
        is proportioned from -100% to 100%. The bandwidth is cenetered
        about the set-point value. The controller ouput power is 100%
        at the end of the bandwidth range above the set-point, it
        decreases to 0% as it reaches the set-point, and is -100% at
        the end of the bandwidth range below the set-point.

        If the bandwidth is too narrow the temperature will oscillate
        around the set-point. If it is too wide the controller will be
        slow to respond.
        """
        val_fp=dec2fp(val)
        val_fp=self._set_value('proportional bandwidth',val_fp)
        return fp2dec(val_fp)

    def get_integral_gain(self):
        """
        Return the controller's integral gain setting in repeats/min. This value 
        should be between INTEGRAL_GAIN_MIN and INTEGRAL_GAIN_MAX.  
        
        If the integral gain is too high, the temperature will
        oscillate. If it is too low it will take a long time to reach
        steady state value.
        """
        val_fp=self._get_value('integral gain')
        val = fp2dec(val_fp)
        if val < INTEGRAL_GAIN_MIN or val > INTEGRAL_GAIN_MAX:
            raise IOError, 'out of range integral gaine returned by get'
        return val

    def set_integral_gain(self, val):
        """
        Set the controller's integral gain in repeats/min. This value
        should be between INTEGRAL_GAIN_MIN and INTEGRAL_GAIN_MAX.
        
        If the integral gain is too high, the temperature will
        oscillate. If it is too low it will take a long time to reach
        steady state value.
        """
        if val < INTEGRAL_GAIN_MIN or val > INTEGRAL_GAIN_MAX:
            raise ValueError, 'out of range integral gain for set'
        val_fp = dec2fp(val)
        val_fp = self._set_value('integral gain',val_fp)
        return fp2dec(val_fp)

    def get_derivative_gain(self):
        """
        Return the controller's derivative gain setting in cycles per
        minute. The derivative gain senses the rate of change of
        temperature and allows the controller to anticipate the power
        need for rapid changes in system loading. Usually this term is
        only used for very sluggish systems or when a very quick
        response is needed.
        """
        val_fp=self._get_value('derivative gain')
        val = fp2dec(val_fp)
        if val < DERIVATIVE_GAIN_MIN or val > DERIVATIVE_GAIN_MAX:
            raise IOError, 'out of range derivative gain returned by get'
        return val
    
    def set_derivative_gain(self,val):
        """
        Set the controller's derivative gain setting in cycles per
        minute. The derivative gain senses the rate of change of
        temperature and allows the controller to anticipate the power
        need for rapid changes in system loading. Usually this term is
        only used for very sluggish systems or when a very quick
        response is needed.
        """
        if val < DERIVATIVE_GAIN_MIN or val > DERIVATIVE_GAIN_MAX:
            raise ValueError, 'out of range derivative gain fro set'
        val_fp=dec2fp(val)
        val_fp=self._set_value('derivative gain', val_fp)
        return fp2dec(val_fp)
        
    def get_low_external_set_range(self):
        """
        Returns the low external set range of the controller. When the
        set-point type is determined by remote input, SETPT_TYPE_VOLTAGE 
        or SETPT_TYPE_CURREN. The high and low external set range values 
        are used to linearly scale the temperature range (or fixed % of 
        output power) to the full range of the external input.  
        """
        val_fp=self._get_value('low external set range')
        return fp2dec(val_fp)

    def set_low_external_set_range(self,val):
        """
        Sets the low external set range of the controller. When the
        set-point type is determined by remote input, SETPT_TYPE_VOLTAGE 
        or SETPT_TYPE_CURREN. The high and low external set range values 
        are used to linearly scale the temperature range (or fixed % of 
        output power) to the full range of the external input.  
        """
        val_fp = dec2fp(val)
        val_fp=self._set_value('high external set range', val_fp)
        return fp2dec(val_fp)

    def get_high_external_set_range(self):
        """
        Returns the high external set range of the controller. When the
        set-point type is determined by remote input, SETPT_TYPE_VOLTAGE 
        or SETPT_TYPE_CURREN. The high and low external set range values 
        are used to linearly scale the temperature range (or fixed % of 
        output power) to the full range of the external input.  
        """
        val_fp=self._get_value('high external set range')
        return fp2dec(val_fp)

    def set_high_external_set_range(self,val):
        """
        Set the high external set range of the controller. When the
        set-point type is determined by remote input, SETPT_TYPE_VOLTAGE 
        or SETPT_TYPE_CURREN. The high and low external set range values 
        are used to linearly scale the temperature range (or fixed % of 
        output power) to the full range of the external input.  
        """
        val_fp=dec2fp(val)
        val_fp = self._set_value('high external set range', val_fp)
        return fp2dec(val_fp)

    def get_alarm_deadband(self):
        """
        Return the controllers alarm deadband setting. The alarm
        deadband is the value that input1 must move (from set-point?)
        in order to toggle alarm output
        """
        val_fp=self._get_value('alarm deadband')
        return fp2dec(val_fp)

    def set_alarm_deadband(self, val):
        """
        Set the controllers alarm deadband. The alarm deadband is the
        value that input1 must move (from set-point?)  in order to
        toggle alarm output
        """
        val_fp=dec2fp(val)
        val_fp=self._set_value('alarm deadband',val_fp)
        return fp2dec(val_fp)

    def get_high_alarm(self):
        """
        Return the controllers high alarm setting. The high alarm
        setting is the temperature to compare against input1 for high
        alarm output.
        """
        val_fp = self._get_value('high alarm setting')
        return fp2dec(val_fp)

    def set_high_alarm(self,val):
        """
        Set the controllers high alarm setting. The high alarm
        setting is the temperature to compare against input1 for high
        alarm output.
        """
        val_fp = dec2fp(val)
        val_fp = self._set_value('high alarm setting',val_fp)
        return fp2dec(val_fp)

    def get_low_alarm(self):
        """
        Return the controllers low alarm setting. The low alarm
        setting is the temperature to compare against input1 for low
        alarm output.
        """
        val_fp = self._get_value('low alarm setting')
        return fp2dec(val_fp)
        
    def set_low_alarm(self,val):
        """
        Set the controllers low alarm setting. The low alarm
        setting is the temperature to compare against input1 for low
        alarm output.
        """
        val_fp = dec2fp(val)
        val_fp = self._set_value('low alarm setting')
        return fp2dec(val_fp)

    def get_control_deadband(self):
        """
        Return the control deadband setting. This is the temperature
        of count span that input1 must move in order to toggle the
        control output.
        """
        val_fp = self._get_value('control deadband setting')
        return fp2dec(val_fp)
    
    def set_control_deadband(self,val):
        """
        Set the control deadband. This is the temperature of count
        span that input1 must move in order to toggle the control
        output.
        """
        val_fp = dec2fp(val)
        val_fp = self._set_value('control deadband setting', val_fp)
        return fp2dec(val_fp)
        
    def get_input1_offset(self):
        """
        Return input1 offset. This value is used to offset input1 in
        order to calibrate external sensor.
        """
        val_fp = self._get_value('input1 offset')
        return fp2dec(val_fp)

    def set_input1_offset(self,val):
        """
        Set input1 offset. This value is used to offset input1 in
        order to calibrate external sensor.
        """
        val_fp = dec2fp(val)
        val_fp = self._get_value('input1 offset',val_fp)
        return fp2dec(val_fp)

    def get_input2_offset(self):
        """
        Return input2 offset. This value is used to offset input2 in
        order to calibrate external sensor.
        """
        val_fp = self._get_value('input2 offset')
        return fp2dec(val_fp)

    def set_input2_offset(self,val):
        """
        Set input2 offset. This value is used to offset input2 in
        order to calibrate external sensor.
        """
        val_fp = dec2fp(val)
        val_fp = self._get_value('input2 offset',val_fp)
        return fp2dec(val_fp)

    def get_heat_multiplier(self):
        """
        Return the controller's heat side multiplier. Numerical
        multiplier used to compensate for the nonsymmetrial response,
        between heat and cool modes, of the thermoelectric cooler.

        Allowed range from HEAT_MULTIPLIER_MIN TO HEAT_MULTIPLIER_MAX.        
        """
        val_fp = self._get_value('heat multiplier')
        val = fp2dec(val_fp)
        if val < HEAT_MULTIPLIER_MIN or val > HEAT_MULTIPLIER_MAX:
            raise IOError, 'heat multiplier out of range from get'
        return val

    def set_heat_multiplier(self,val):
        """
        Set the controller's heat side multiplier. Numerical multiplier
        used to compensate for the nonsymmetrial response, between
        heat and cool modes, of the thermoelectric cooler.

        Allowed range from HEAT_MULTIPLIER_MIN TO HEAT_MULTIPLIER_MAX.        
        """
        if val < HEAT_MULTIPLIER_MIN or val > HEAT_MULTIPLIER_MAX:
            raise ValueError, 'heat multiplier out of range for set'
        val_fp = dec2fp(val)
        val_fp = self._set_value('heat multiplier',val_fp)
        return fp2dec(val_fp)

    def get_cool_multiplier(self):
        """
        Return the controller's cool side multiplier. Numerical
        multiplier used to compensate for the nonsymmetrial response,
        between heat and cool modes, of the thermoelectric cooler.

        Allowed range from COOL_MULTIPLIER_MIN TO COOL_MULTIPLIER_MAX.        
        """
        val_fp = self._get_value('cool multiplier')
        val = fp2dec(val_fp)
        if val < COOL_MULTIPLIER_MIN or val > COOL_MULTIPLIER_MAX:
            raise IOError, 'cool multiplier out of range from get'
        return val

    def set_cool_multiplier(self,val):
        """
        Set the controller's cool side multiplier. Numerical multiplier
        used to compensate for the nonsymmetrial response, between
        heat and cool modes, of the thermoelectric cooler.

        Allowed range from COOL_MULTIPLIER_MIN TO COOL_MULTIPLIER_MAX.        
        """
        if val < COOL_MULTIPLIER_MIN or val > COOL_MULTIPLIER_MAX:
            raise ValueError, 'cool multiplier out of range for set'
        val_fp = dec2fp(val)
        val_fp = self._set_value('cool multiplier',val_fp)
        return fp2dec(val_fp)

    def get_over_current_compare(self):
        """
        Return the controller's over current compare value in
        Amps. This is the value which determines an over-current
        condition - the level at which over current protection for the
        device shuts the output off. 
        """
        val = self._get_value('over current count compare value')
        val_amp = cnt2amp(val)
        if val_amp < OVER_CURRENT_MIN or val_amp > OVER_CURRENT_MAX:
            raise IOError, 'over current compare value out of range from get'
        return val_amp

    def set_over_current_compare(self,val):
        """
        Return the controller's over current compare value in
        Amps. This is the value which determines an over-current
        condition - the level at which over current protection for the
        device shuts the output off. 
        """
        if val < OVER_CURRENT_MIN or val > OVER_CURRENT_MAX:
            raise ValueError, 'over current compare value out of range for set'
        val_cnt = amp2cnt(val)
        val_cnt = self._set_value('over current count compare value', val_cnt)
        return cnt2amp(val_cnt)

    def get_alarm_latch(self):
        """
        Return alarm latch setting. Allowed values ALARM_LATCH_ON,
        ALARM_LATCH_OFF.
        """
        val = self._get_value('alarm latch enable')
        if not val in ALARM_LATCH_TYPES:
            raise IOError, 'unkown alarm latch type return from get'
        return val

    def set_alarm_latch(self,val):
        """
        Set the controller's alarm latch setting. Allowed values
        ALARM_LATCH_ON, ALARM_LATCH_OFF.
        """
        if not val in ALARM_LATCH_TYPES:
            raise ValueError, 'unkown alarm latch type return for set'
        val = self._set_value('alarm latch enable', val)
        return val

    def alarm_latch_reset(self):
        """
        Reset the controllers alarm latches
        """
        print '** warning - not sure if this is correct'
        self._set_value('alarm latch request',0)

    def get_alarm_sensor(self):
        """
        Return the current alarm sensor setting. Allowed values
        ALARM_SENSOR_INPUT1 and ALARM_SENSOR_INPUT2.
        """
        val=self._get_value('choose sensor for alarm function')
        if not val in ALARM_SENSOR_TYPES:
            raise IOError, 'unknown alarm sensor type from get'
        return val

    def set_alarm_sensor(self,val):
        """
        Set the controller's alarm sensor type. Allowed values
        ALARM_SENSOR_INPUT1 and ALARM_SENSOR_INPUT2.
        """
        if not val in ALARM_SENSOR_TYPES:
            raise ValueError, 'unknown alarm sensor type for set'
        val = self._set_value('choose sensor for alarm function',val)
        return val

    def get_working_units(self):
        """
        Return the controller's current working units. Allows values
        TEMP_F or TEMP_C.
        """
        val=self._get_value('temperature working units')
        if not val in TEMP_TYPES:
            raise IOError, 'unknown temperature type from get'
        return val
        
    def set_working_units(self, val):
        """
        Set the controller's current working units. Allows values
        TEMP_F or TEMP_C.
        """
        if not val in TEMP_TYPES:
            raise ValueError, 'unknown temperature type for set'
        val=self._set_value('temperature working units',val)
        return val

    def get_eeprom_write(self):
        """
        Return the controller's eeprom write setting. Allowed values
        EEPROM_WRITE_OFF and EPROM_WRITE_ON.

        If the eeprom write setting is set EEPROM_WRITE_ON then all write 
        will be sotred to both ram and eeprom. 
        """
        val = self._get_value('eeprom write enable')
        if not val in EEPROM_WRITE_TYPES:
            raise IOError, 'unknown eeprom write type from get'
        return val
    
    def set_eeprom_write(self,val):
        """
        Set the controller's eeprom write setting. Allowed values
        EEPROM_WRITE_OFF and EPROM_WRITE_ON.

        If the eeprom write setting is set EEPROM_WRITE_ON then all write 
        will be sotred to both ram and eeprom. 
        """
        if not val in EEPROM_WRITE_TYPES:
            raise ValueError, 'unknown eeprom write type for set'
        val = self._set_value('eeprom write enable',val)
        return val

    def get_over_current_restart_type(self):
        """
        Return the controller's over current restart setting. Allowed values
        OVER_CURRENT_RESTART_CONTINOUS an OVER_CURRENT_RESTART_MAX_ATTEMPT.
        """
        val=self._get_value('over current continuous')
        if not val in OVER_CURRENT_RESTART_TYPES:
            raise IOError, 'unknown over current restart type from get'
        return val

    def set_over_current_restart_type(self,val):
        """
        Set the controller's over current restart setting. Allowed values
        OVER_CURRENT_RESTART_CONTINOUS an OVER_CURRENT_RESTART_MAX_ATTEMPT.
        """
        if not val in OVER_CURRENT_RESTART_TYPES:
            raise ValueError, 'unknown over current restart type for set'
        val=self._set_value('over current continuous',val)
        return val

    def get_over_current_restart_num(self):
        """
        Return the controller's over current restart attempt
        number. This the number of times the controller will atempt
        to restart the output after an over current condiiton.
        """
        val = self._get_value('over current restart attempts')
        if val < OVER_CURRENT_RESTART_MIN or val > OVER_CURRENT_RESTART_MAX:
            raise IOError, '# over current restart attempts out of range from get'
        return val
        
    def set_over_current_restart_num(self,val):
        """
        Set the controller's over current restart attempt
        number. This the number of times the controller will atempt
        to restart the output after an over current condiiton.
        """
        if val < OVER_CURRENT_RESTART_MIN or val > OVER_CURRENT_RESTART_MAX:
            raise ValueError, '# over current restart attempts out of range for set'
        val=self._set_value('over current restart attempts',val)
        return val

    def get_JP3_display(self):
        """
        Return the controller's JP3 display enable setting. Allowed values
        JP3_DISPLAY_OFF and JP3_DISPLAY_ON
        """
        val=self._get_value('JP3 display enable')
        if not val in JP3_DISPLAY_TYPES:
            raise IOError, 'unknown JP3 display type from get'
        return val

    def set_JP3_display(self,val):
        """
        Set the controller's JP3 display enable setting. Allowed values
        JP3_DISPLAY_OFF and JP3_DISPLAY_ON 
        """
        if not val in JP3_DISPLAY_TYPES:
            raise ValueError, 'unknown JP3 display type for set'
        val=self._set_value('JP3 display enable', val)
        return val

# --------------------------------------------------------------------
def fp2dec(x):
    """
    Convert tc3625 fixed temperature number to decimal number
    """
    return x/100.0

def dec2fp(x):
    """
    Convert decimal number to tc3625 fixed temperature number
    """
    return int(100*x)


def amp2cnt(x):
    """
    Convert amps to counts
    """
    return x/AMPS_PER_COUNT
    

def cnt2amp(x):
    """
    Convert counts to amps
    """
    return x*AMPS_PER_COUNT


def val2str(prop_str,val):
    """
    Convert a proprty value to a string
    """

    if prop_str=='alarm status':
        flag, alarms = val
        val_str = '%s'%(str(flag),)
        if len(alarms) > 0:
            alarms_str = []
            for a in alarms:
                alarms_str.append(ALARM_STR[a])
            val_str = '%s, %s'%(str(alarms_str),)
    elif prop_str=='alarm type':
        val_str = ALARM_STR[val]
    elif prop_str=='setpt type':
        val_str = SETPT_STR[val]
    elif prop_str=='sensor type':
        val_str = SENSOR_TYPE_STR[val]
    elif prop_str=='control type':
        val_str = CONTROL_TYPE_STR[val]
    elif prop_str=='output polarity':
        val_str = POLARITY_STR[val]
    elif prop_str=='power state':
        val_str = POWER_STR[val]
    elif prop_str == 'shutdown if alarm':
        val_str = SHUTDOWN_IF_ALARM_STR[val]
    elif prop_str=='alarm latch':
        val_str = ALARM_LATCH_STR[val]
    elif prop_str=='alarm sensor':
        val_str = ALARM_SENSOR_STR[val]
    elif prop_str=='working units':
        val_str = TEMP_STR[val]
    elif prop_str=='eeprom write':
        val_str = EEPROM_WRITE_STR[val]
    elif prop_str=='over current restart type':
        val_str = OVER_CURRENT_RESTART_STR[val]
    elif prop_str=='JP3 display':
        val_str=JP3_DISPLAY_STR[val]
    else:
        val_str = str(val)
    return val_str

